import math
from sympy import mod_inverse

# step 1
p = 2468101214161820222426283032343638404244464850525456586062646668707274767880828486889092949698100102104106108110112114116118120122124126128130132134136138140142144146148150152154156158160162164166168170172174176178180182184186188190192194196198200202204206208210212214216218220222224226228230232234236238240242244246248250252254256258260262264266268270272274276278280282284286288290292294296298300302304306308310312314316318320322324326328330332334336338340342344346348350352354356358360362364366368370372374376378380382384386388390392394396398400402404406408410412414416418420422424426428430432434436438440442444446448450451

q = 4531237355389378252167998204069912329623238122031742525328375168700640071230382841176538537641410229241210453089727044117359137139455328859431837448826486544033819286028482023523368963132036246337749117510181791772392419630160691233539397666404977367459896404859268755714147264101378375452001615625546366367347635604604983153448409986447938745141330803902556457519623807485807874059361289422468644305915480952509665275858944824184377172418429729023520527815721212827456904706203130970930562002244147732153879979550528775145262679261139839149750738281823331233898450596958081662801176207041676910592588281955660174518029203


# step 2
n = p * q
print("n =", n)

# step 3
phi = (p - 1) * (q - 1)

# step 4
e = 12476887212021993442110199358752708924701803529059621093175425622733669467883949947675691475234619840011834907311190217746675989939216650576888857297178001403056607788173793659721519220407882836961485677701159975750390138203851217402392454956005136742255031959890511956859557608720511520058853969357120864446881543218382526647078638709071460669057484987187411974923404489695748418478767371507593607813077469421533128726917169213528495535265695658025714101916940969259166800885637644191776796994966368736184684887140181414647161683450038419593746287816314338161257353997108257593617988524369362310588581266068939675326027669497114879679046038423151758563663992545459471708675025023159091918738054836312530096887116627576765886836332242384589550677760173524776401596166561048772007836660782542723137806002228329694821136437125248879104380878605346854064161270003699426713321418697952142790909039713593442343136585458253528395537953163968403727546715054084005501503972372937126857768774412426981166583498541172324894492507227939862487991874328502902724366716535471281434150957384078323796582302111849142771371661806255270473692274380949379349855641011364277002743833951136056247725430654018957290228667

while e < phi:
    if math.gcd(e, phi) == 1:
        break
    else:
        e += 1

print("e =", e)
# Calculate private exponent d using modular inverse
d = mod_inverse(e, phi)
print("d =", d)

print(f"Public key: {e, n}")
print(f"Private key: {d, n}")

# # encryption
# C = pow(msg, e)
# C = math.fmod(C, n)
# print(f"Encrypted message: {C}")

# # decryption
# M = pow(C, d)
# M = math.fmod(M, n)

# print(f"Decrypted message: {M}")
